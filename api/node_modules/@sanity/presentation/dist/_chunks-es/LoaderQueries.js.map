{"version":3,"file":"LoaderQueries.js","sources":["../../../visual-editing-helpers/dist/hooks.js","../../src/loader/LoaderQueries.tsx"],"sourcesContent":["import{useMemo as e,useState as n,useCallback as t,useEffect as i,useSyncExternalStore as r}from\"react\";function o(n){const t=e((()=>JSON.stringify(n||{})),[n]);return e((()=>JSON.parse(t)),[t])}function s(e){const{refreshInterval:o}=e,s=function(){const[e,t]=n(!1);i((()=>{t(navigator.onLine);const e=()=>t(!0),n=()=>t(!1);return window.addEventListener(\"online\",e),window.addEventListener(\"offline\",n),()=>{window.removeEventListener(\"online\",e),window.removeEventListener(\"offline\",n)}}),[]);const o=r(d,(()=>document.visibilityState),(()=>\"hidden\"));return!e||\"hidden\"===o}(),[c,u]=n(\"hit\"),a=t((()=>(u(\"inflight\"),()=>u(\"hit\"))),[]);return i((()=>{if(!o||\"hit\"!==c)return;const e=setTimeout((()=>u(\"stale\")),o);return()=>clearTimeout(e)}),[o,c]),i((()=>{if(\"hit\"!==c)return;const e=()=>u(\"stale\");return window.addEventListener(\"focus\",e),()=>window.removeEventListener(\"focus\",e)}),[o,c]),i((()=>{s&&\"hit\"===c&&u(\"stale\"),!s&&\"stale\"===c&&u(\"refresh\")}),[s,c]),[c,a]}function d(e){return document.addEventListener(\"visibilitychange\",e),()=>document.removeEventListener(\"visibilitychange\",e)}export{o as useQueryParams,s as useRevalidate};//# sourceMappingURL=hooks.js.map\n","import type {ChannelsController} from '@repo/channels'\nimport type {LoaderMsg, VisualEditingConnectionIds} from '@repo/visual-editing-helpers'\nimport {useQueryParams, useRevalidate} from '@repo/visual-editing-helpers/hooks'\nimport type {ClientConfig, ClientPerspective, ContentSourceMap, QueryParams} from '@sanity/client'\nimport {applySourceDocuments, getPublishedId} from '@sanity/client/csm'\nimport {applyPatch} from 'mendoza'\nimport LRUCache from 'mnemonist/lru-cache-with-delete'\nimport {memo, useEffect, useMemo, useState} from 'react'\nimport {type SanityClient, type SanityDocument, useClient} from 'sanity'\n\nimport {LIVE_QUERY_CACHE_BATCH_SIZE, LIVE_QUERY_CACHE_SIZE} from '../constants'\nimport type {LiveQueriesState} from '../types'\n\nexport interface LoaderQueriesProps {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  channel: ChannelsController<VisualEditingConnectionIds, LoaderMsg> | undefined\n  perspective: ClientPerspective\n  liveQueries: LiveQueriesState\n  documentsOnPage: {_id: string; _type: string}[]\n}\n\nexport default function LoaderQueries(props: LoaderQueriesProps): JSX.Element {\n  const {\n    liveDocument,\n    channel,\n    perspective: activePerspective,\n    liveQueries,\n    documentsOnPage,\n  } = props\n  const [cache] = useState(() => new LRUCache<string, SanityDocument>(LIVE_QUERY_CACHE_SIZE))\n  const studioClient = useClient({apiVersion: '2023-10-16'})\n  const clientConfig = useMemo(() => studioClient.config(), [studioClient])\n  const client = useMemo(\n    () =>\n      studioClient.withConfig({\n        resultSourceMap: 'withKeyArraySelector',\n      }),\n    [studioClient],\n  )\n  useEffect(() => {\n    if (channel) {\n      const {projectId, dataset} = clientConfig\n      // @todo - Can this be migrated/deprecated in favour of emitting\n      // `presentation/perspective` at a higher level?\n      channel.send('loaders', 'loader/perspective', {\n        projectId: projectId!,\n        dataset: dataset!,\n        perspective: activePerspective,\n      })\n    }\n  }, [channel, clientConfig, activePerspective])\n\n  const turboIds = useMemo(() => {\n    const documentsActuallyInUse = documentsOnPage.map(({_id}) => _id)\n    const set = new Set(documentsActuallyInUse)\n    const ids = [...set]\n    const max = cache.capacity\n    if (ids.length >= max) {\n      ids.length = max\n    }\n    return ids\n  }, [cache.capacity, documentsOnPage])\n\n  const [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0)\n\n  return (\n    <>\n      <Turbo\n        cache={cache}\n        client={client}\n        turboIds={turboIds}\n        setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n      />\n      {Object.entries(liveQueries).map(([key, {query, params, perspective}]) => (\n        <QuerySubscription\n          key={`${key}${perspective}`}\n          cache={cache}\n          projectId={clientConfig.projectId!}\n          dataset={clientConfig.dataset!}\n          perspective={perspective}\n          query={query}\n          params={params}\n          channel={channel}\n          client={client}\n          refreshInterval={activePerspective ? 2000 : 0}\n          liveDocument={liveDocument}\n          documentsCacheLastUpdated={documentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n}\n\ninterface SharedProps {\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * The documents cache to use for turbo-charging queries.\n   */\n  cache: LRUCache<string, SanityDocument>\n}\n\ninterface TurboProps extends Pick<SharedProps, 'client' | 'cache'> {\n  turboIds: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const {cache, client, turboIds, setDocumentsCacheLastUpdated} = props\n  // Figure out which documents are missing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (!batchSet.has(turboId) && !cache.has(turboId)) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE)\n    if (nextBatchSlice.length === 0) return\n    setBatch((prevBatch) => [...prevBatch.slice(-LIVE_QUERY_CACHE_BATCH_SIZE), nextBatchSlice])\n  }, [batch, cache, turboIds])\n\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        '*',\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'presentation-loader',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type === 'mutation' && update.transition === 'disappear') {\n          if (cache.delete(update.documentId)) {\n            setDocumentsCacheLastUpdated(Date.now())\n          }\n        }\n\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const cachedDocument = cache.peek(update.documentId)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = {...cachedDocument} as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          cache.set(update.documentId, patchedDocument)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      })\n    return () => subscription.unsubscribe()\n  }, [cache, client, setDocumentsCacheLastUpdated])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          cache={cache}\n          client={client}\n          ids={ids}\n          setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n})\n\ninterface GetDocumentsProps extends Pick<SharedProps, 'client' | 'cache'> {\n  ids: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const {client, cache, ids, setDocumentsCacheLastUpdated} = props\n\n  useEffect(() => {\n    const missingIds = ids.filter((id) => !cache.has(id))\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          cache.set(doc._id, doc)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [cache, client, ids, setDocumentsCacheLastUpdated])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\ninterface QuerySubscriptionProps\n  extends Pick<\n    UseQuerySubscriptionProps,\n    'client' | 'cache' | 'refreshInterval' | 'liveDocument' | 'documentsCacheLastUpdated'\n  > {\n  projectId: string\n  dataset: string\n  perspective: ClientPerspective\n  query: string\n  params: QueryParams\n  channel: ChannelsController<VisualEditingConnectionIds, LoaderMsg> | undefined\n}\nfunction QuerySubscription(props: QuerySubscriptionProps) {\n  const {\n    cache,\n    projectId,\n    dataset,\n    perspective,\n    query,\n    client,\n    refreshInterval,\n    liveDocument,\n    channel,\n    documentsCacheLastUpdated,\n  } = props\n\n  const params = useQueryParams(props.params)\n  const data = useQuerySubscription({\n    cache,\n    client,\n    liveDocument,\n    params,\n    perspective,\n    query,\n    refreshInterval,\n    documentsCacheLastUpdated,\n  })\n  const result = data?.result\n  const resultSourceMap = data?.resultSourceMap\n\n  useEffect(() => {\n    if (resultSourceMap) {\n      channel!.send('loaders', 'loader/query-change', {\n        projectId,\n        dataset,\n        perspective,\n        query,\n        params,\n        result,\n        resultSourceMap,\n      })\n    }\n  }, [channel, dataset, params, perspective, projectId, query, result, resultSourceMap])\n\n  return null\n}\n\ninterface UseQuerySubscriptionProps\n  extends Required<Pick<SharedProps, 'client' | 'refreshInterval' | 'cache'>> {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  query: string\n  params: QueryParams\n  perspective: ClientPerspective\n  documentsCacheLastUpdated: number\n}\nfunction useQuerySubscription(props: UseQuerySubscriptionProps) {\n  const {\n    cache,\n    liveDocument,\n    client,\n    refreshInterval,\n    query,\n    params,\n    perspective,\n    documentsCacheLastUpdated,\n  } = props\n  const [snapshot, setSnapshot] = useState<{\n    result: unknown\n    resultSourceMap?: ContentSourceMap\n  } | null>(null)\n  const {projectId, dataset} = useMemo(() => {\n    const {projectId, dataset} = client.config()\n    return {projectId, dataset} as Required<Pick<ClientConfig, 'projectId' | 'dataset'>>\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({refreshInterval})\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    let fetching = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const {signal} = controller\n      fetching = true\n      const {result, resultSourceMap} = await client.fetch(query, params, {\n        tag: 'presentation-loader',\n        signal,\n        perspective,\n        filterResponse: false,\n      })\n      fetching = false\n\n      if (!signal.aborted) {\n        setSnapshot({result, resultSourceMap})\n\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        fetching = false\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled && !fetching) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    liveDocument,\n    params,\n    perspective,\n    projectId,\n    query,\n    shouldRefetch,\n    startRefresh,\n  ])\n\n  return useMemo(() => {\n    if (documentsCacheLastUpdated && snapshot?.resultSourceMap) {\n      return {\n        result: turboChargeResultIfSourceMap(\n          cache,\n          liveDocument,\n          snapshot.result,\n          perspective,\n          snapshot.resultSourceMap,\n        ),\n        resultSourceMap: snapshot.resultSourceMap,\n      }\n    }\n    return snapshot\n  }, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot])\n}\n\nlet warnedAboutCrossDatasetReference = false\nexport function turboChargeResultIfSourceMap<T = unknown>(\n  cache: SharedProps['cache'],\n  liveDocument: Partial<SanityDocument> | null | undefined,\n  result: T,\n  perspective: ClientPerspective,\n  resultSourceMap?: ContentSourceMap,\n): T {\n  if (perspective === 'raw') {\n    throw new Error('turboChargeResultIfSourceMap does not support raw perspective')\n  }\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      // If there's a displayed document, always prefer it\n      if (\n        liveDocument?._id &&\n        getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)\n      ) {\n        return liveDocument\n      }\n      // Fallback to general documents cache\n      return cache.get(sourceDocument._id)\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, {previousValue}) => {\n      if (typeof changedValue === 'number' && typeof previousValue === 'string') {\n        // If the string() function was used in the query, we need to convert the source value to a string as well\n        return `${changedValue}`\n      }\n      return changedValue\n    },\n    perspective,\n  )\n}\n"],"names":["d","e","document","addEventListener","removeEventListener","LoaderQueries","props","liveDocument","channel","perspective","activePerspective","liveQueries","documentsOnPage","cache","useState","LRUCache","LIVE_QUERY_CACHE_SIZE","studioClient","useClient","apiVersion","clientConfig","useMemo","config","client","withConfig","resultSourceMap","useEffect","projectId","dataset","send","turboIds","documentsActuallyInUse","map","_id","ids","Set","max","capacity","length","documentsCacheLastUpdated","setDocumentsCacheLastUpdated","jsxs","Fragment","children","jsx","Turbo","Object","entries","key","query","params","QuerySubscription","refreshInterval","memo","batch","setBatch","batchSet","flat","nextBatch","turboId","has","add","nextBatchSlice","slice","LIVE_QUERY_CACHE_BATCH_SIZE","prevBatch","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","subscribe","update","type","transition","delete","documentId","Date","now","effects","apply","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","set","unsubscribe","GetDocuments","JSON","stringify","missingIds","filter","id","getDocuments","then","documents","doc","console","error","n","t","parse","useQueryParams","data","snapshot","setSnapshot","setError","revalidate","startRefresh","o","s","i","navigator","onLine","window","r","visibilityState","c","u","a","setTimeout","clearTimeout","s2","useRevalidate","shouldRefetch","fulfilled","fetching","controller","AbortController","async","effect","signal","result","fetch","filterResponse","aborted","onFinally","catch","name","finally","abort","turboChargeResultIfSourceMap","useQuerySubscription","displayName","warnedAboutCrossDatasetReference","Error","applySourceDocuments","sourceDocument","_projectId","getPublishedId","get","warn","changedValue","previousValue"],"mappings":"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"}